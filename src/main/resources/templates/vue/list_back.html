<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      xmlns:v-bind="http://www.w3.org/1999/xhtml"
      xmlns:v-on="http://www.w3.org/1999/xhtml"
      layout:decorator="layouts/layout"
      >

<body>
<dev layout:fragment="content">
    <div id="example">
        <li v-for="item in items">
            {{ item.message }}
        </li>
        <li v-for="(item, index) in items">
            {{ parentMessage }} - {{ index }} - {{ item.message }}
        </li>

        <h1>v-for와 객체</h1>
        <ul id="v-for-object" class="demo">
            <li v-for="value in object">
                {{ value }}
            </li>
        </ul>
        <div v-for="(value, key) in object">
            {{ key }}: {{ value }}
        </div>
        <div v-for="(value, key, index) in object">
            {{ index }}. {{ key }} : {{ value }}
        </div>

        <h1>key</h1>
        <p>Vue에서 개별 DOM 노드들을 추적하고 기존 엘리먼트를 재사용, 재정렬하기 위해서 v-for의 각 항목들에 고유한 key 속성을 제공해야 합니다. </p>

        <div v-for="item in items" :key="item.id">
            <!-- content -->
            {{ item.message }}
        </div>
        <h1>배열 변경 감지</h1>
        <p>Vue는 감시중인 배열의 변이 메소드를 래핑하여 뷰 갱신을 트리거합니다. 래핑된 메소드는 다음과 같습니다.</p>
        <ol>
            <li>push()</li>
            <li>pop()</li>
            <li>shift()</li>
            <li>unshift()</li>
            <li>splice()</li>
            <li>sort()</li>
            <li>reverse()</li>
        </ol>
        <p>
            콘솔을 열고 이전 예제의 items 배열로 변이 메소드를 호출하여 재생할 수 있습니다. 예: example1.items.push({ message: 'Baz' })
        </p>

        <h1>배열 대체</h1>
        <p>이름에서 알 수 있듯 변이 메소드는 호출된 원본 배열을 변형합니다. 이와 비교하여 변형을 하지 않는 방법도 있습니다. 바로 filter(), concat() 와 slice() 입니다. 이 방법을 사용하면 원본 배열을 변형하지 않고 항상 새 배열을 반환합니다. 변형이 없는 방법으로 작업할 때 이전 배열을 새 배열로 바꿀 수 있습니다.</p>
        <p>
            example1.items = example1.items.filter(function (item) {
            return item.message.match(/Foo/)
            })

        </p>

        <h1>필터링 / 정렬 된 결과 표시하기</h1>
        <li v-for="n in evenNumbers">{{ n }}</li>

        <p>계산된 속성을 실행할 수 없는 상황(예: 중첩 된 v-for 루프 내부)에서는 다음 방법을 사용할 수 있습니다.</p>
        <li v-for="n in even(numbers)">{{ n }}</li>


        <div>
            <span v-for="n in 10">{{ n }} </span>
        </div>

        <h1>v-for 템플릿</h1>
        <p>템플릿 v-if와 마찬가지로, <template>태그를 사용해 여러 엘리먼트의 블럭을 렌더링 할 수 있습니다.</p>
        <ul>
            <template v-for="item in items">
                <li>{{ item.message }}</li>
                <li class="divider"></li>
            </template>
        </ul>

    </div>


    <script th:inline="javascript">
        let vm = new Vue({
            el: '#example',
            data: {
                parentMessage: 'Parent',
                items: [
                  { message: 'Foo'},
                  { message: 'Bar'},
                  { message: 'san'},
                  { message: 'buu'}
                ],
                items2: [
                  { message: 'Foo'},
                  { message: 'Foo222'},
                  { message: 'san'},
                  { message: 'buu'}
                ],
                object: {
                    firstName: 'John',
                    lastName: 'Doe',
                    age: 30
                },
                numbers: [ 1, 2, 3, 4, 5 ]
            },
            computed: {
                evenNumbers: function () {
                    return this.numbers.filter(function (number) {
                        return number % 2 === 0;
                    })
                }
            },
            methods: {
                even: function (numbers) {
                    return numbers.filter(function (number) {
                        return number % 2 === 0;
                    })
                }
            }
        });

/*
        vm.items2 = vm.items2.filter(function (item) {
            return item.message.match(/Foo/);
        });
*/


    </script>
</dev >
</body>
</html>